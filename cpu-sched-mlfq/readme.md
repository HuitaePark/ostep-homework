1. 두 개의 작업과 두 개의 큐를 무작위로 구성하여 실행시켜 보시오.
각 문제에 대한 MLFQ 실행 추적을 계산하시오.
문제를 쉽게 하기 위해 각 작업의 길이를 제한하고 입출력은 하지 않는다고 가정하시오.

![image](https://github.com/user-attachments/assets/dfef9abd-8c5f-4f6a-a5d9-aeaa8d67b12e)


2. 이 장의 예제를 재현하려면 스케줄러를 어떻게 실행해야 하는가?



3. 라운드 로빈 스케줄러처럼 동작시키려면 스케줄러의 매개변수를 어떻게 설정해야 하는가?

'-n 1' 큐룰 하나만 두어 모든 작업의 우선순위를 같게합니다

4. 두 개의 작업과 스케줄러 매개변수를 가진 워크로드를 고려하시오.
두 작업 중 하나의 작업은 옛날 규칙 4a 및 4b를 이용하여 (-S 플래그를 켠다) 스케줄러를 자신에게 유리하게 동작하도록 만들어 특정 구간에서 99%의 CPU를 차지하도록 고려해야 한다.

'-n 2 -S' + 각 작업의 i/o 작업이 타임 퀀텀 시간 이내에 발생하는 워크로드

5. 가장 높은 우선순위 큐의 타임 퀀텀의 길이가 10 ms인 시스템이 있다고 하자.
하나의 장기 실행 (및 잠재적인 기아 위험) 작업이 적어도 5%의 CPU를 사용할 수 있도록 보장하려면
얼마나 자주 가장 높은 우선순위로 이동시켜야 하는가 (-B 플래그 켠다)?

5% = 5 / 100 = 10 / x
x = 200 이므로
200ms 마다 부스트하면 최소 5퍼센트의 cpu를 사용할 수 있습니다.

6. 스케줄링에서 제기되는 질문 중 하나는, 입출력이 방금 종료된 작업은 큐의 어느 쪽에 추가해야 하는가이다.
플래그 -I가 시뮬레이터의 이 행동 양식을 변경한다.
몇 개의 워크로드를 가지고 실험하여 이 플래그의 영향을 확인할 수 있는지 보라.


i/o 작업이 자주 발생하는 작업이 있는 워크로드에서 i/o 위주 작업은 cpu 사용 시간이 짧거나 응답속도가 중요한 대화형 작업일 수 있습니다.
이러한 작업들이 먼저 수행되도록 함으로써 i/o 결과를 기다리는 동안 다른 cpu 작업을 처리하여
하드웨어를 효율적으로 사용할 수 있고 짧은 응답속도를 보장할 수 있습니다.
-I 플래그를 통해 큐의 앞쪽에 추가함으로써 i/o 위주 작업이 가능한 먼저 실행하도록 할 수 있습니다.
