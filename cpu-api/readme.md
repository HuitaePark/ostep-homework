# 문제

1. fork()를 호출하는 프로그램을 작성하라.
fork()를 호출하기 전에 메인 프로세스는 변수에 접근하고 (예, x) 변수에 값을 지정하라 (예, 100).
자식 프로세스에서 그 변수의 값은 무엇인가?
부모와 자식이 변수 x를 변경한 후에 변수는 어떻게 변했는가?

 

자식 프로세스에서 변수값을 200으로 수정한후 출력하면 200이 출력되지만
자식 프로세스가 종료된 후 부모 프로세스에서 출력했을 때는 그대로 100이므로

자식 프로세스의 메모리와 부모 프로세스의 메모리가 서로 독립적이라는 것을 알 수 있습니다.

 

2. open() 시스템 콜을 사용하여 파일을 여는 프로그램을 작성하고 새 프로세스를 생성하기 위하여 fork()를 호출하라.

자식과 부모가 open()에 의해 반환된 파일 디스크립터에 접근할 수 있는가?

부모와 자식 프로세스가 동시에 파일에 쓰기 작업을 할 수 있는가?

 

부모 프로세스에서 파일을 오픈하고 반환된 파일 디스크립터는 자식 프로세스에서도 접근 가능하며

부모 프로세스와 자식 프로세스는 동시에 쓰기 작업이 가능합니다.

 

3. fork()를 사용하는 다른 프로그램을 작성하라.

자식 프로세스는 “hello”를 출력하고 부모 프로세스는 “goodbye”를 출력해야 한다.

항상 자식 프로세스가 먼저 출력하게 하라.

부모가 wait()를 호출하지 않고 할 수 있는가?


vfork를 사용하여 자식 프로세스가 종료될 때 까지 부모 프로세스를 대기하게 할 수 있었습니다.

그 외에는 세마포어 등의 락을 사용하여 자식 프로세스가 종료될 때 까지 부모 프로세스의 실행을 막거나
부모 프로세스를 일정 시간 sleep 시켜 자식 프로세스가 먼저 실행되도록 유도할 수 있지만
이 방법은 항상 자식 프로세스가 먼저 실행되는 것을 보장되지는 않습니다.

 

4. fork()를 호출하고 /bin/ls를 실행하기 위하여 exec() 계열의 함수를 호출 하는 프로그램을 작성하라.

exec()의 변형 execl(), execle(), execlp(), execv(), execvp(), execve() 모두를 사용할 수 있는지 시도해 보라.

기본적으 로는 동일한 기능을 수행하는 시스템 콜에 여러 변형이 있는 이유를 생각해 보라.

 

모두 사용할 수 있습니다.

system 함수가 원형이며 추가적으로 인자나 환경 변수를 전달하거나 PATH를 참조하게 하기 위해
옵션 별로 나눠져 있는 것 같습니다.

 

5. wait()를 사용하여 자식 프로세스가 종료되기를 기다리는 프로그램을 작성하라.

wait()가 반환하는 것은 무엇인가? 자식 프로세스가 wait()를 호출하면 어떤 결과가 발생하는가?

 

wait()의 반환 값은 자식 프로세스의 pid이고

자식 프로세스에서 wait() 함수를 사용했을 떄 자식의 자식 프로세스가 없다면 -1이 반환됩니다.

 

6. 위 문제에서 작성한 프로그램을 수정하여 wait() 대신에 waitpid()를 사용하라.

어떤 경우에 waitpid()를 사용하는 것이 좋은가?

 

waitpid() 함수를 사용하면 기다릴 자식 프로세스를 지정할 수 있고

세번째 인자를 통해서는 자식 프로세스가 종료될 때 까지 기다리지 않도록 설정할 수도 있습니다.

특정 자식 프로세스의 종료를 기다려야하는 상황이거나
자식 프로세스의 실행을 반드시 기다릴 필요가 없는 상황에 유용할 것 같습니다.

 

7. 자식 프로세스를 생성하고 자식 프로세스가 표준 출력 (STDOUT_FILENO)을 닫는 프 로그램을 작성하라.

자식이 설명자를 닫은 후에 아무거나 출력하기 위하여 printf() 를 호출하면 무슨 일이 생기는가?


자식 프로세스가 생성되고 파일 디스크립터 테이블 또한 복사되었으므로
자식 프로세스에서 표준 출력을 닫아도 부모 프로세스는 출력이 가능합니다.

 

8. 두 개의 자식 프로세스를 생성하고 pipe() 시스템 콜을 사용하여
한 자식의 표준 출력을 다른 자식의 입력으로 연결하는 프로그램을 작성하라.
```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main(int argc, char* argv[]) {
    int fd[2];

    pipe(fd);

    int pid1 = fork();

    if (pid1 == -1) {
        return -1;
    }

    if (pid1 > 0) {
        close(fd[1]);
        printf("receiver(waiting)\n");
        char c;
        while (read(fd[0], &c, 1) > 0) {
            printf("%c", c);
        }
        return 0;
    }

    int pid2 = fork();

    if (pid2 == -1) {
        return -1;
    }

    if (pid2 > 0) {
        close(fd[0]);
        printf("sender\n");
        char message[] = "this is message";
        write(fd[1], message, sizeof(message));
        return 0;
    }

    waitpid(pid1, NULL, 0);
}
```
