## 문제
1. 다음과 같이 플래그를 지정하고 프로그램을 실행시키시오: ./process-run.py -l 5:100,5:100.
CPU 이용률은 얼마가 되어야 하는가(예, CPU가 사용 중인 시간의퍼센트?) 그러한 이용률을 예측한 이유는 무엇인가?
-c 플래그를 지정하여 예측이맞는지 확인하시오

50:50퍼센트 IO가 하나도 없기 때문에 두 프로세스가 CPU를 반반 나눠가진다  
<img width="884" height="344" alt="image" src="https://github.com/user-attachments/assets/012f6f1f-53e3-4ea2-a859-12afc7b24e52" />

2. 이제 다음과 같이 플래그를 지정하고 실행시키시오: ./process-run.py -l
4:100, 1:0. 이 플래그는 4개의 명령어를 실행하고 모두 CPU만 사용하는 하나의
프로세스와 오직 입출력을 요청하고 완료되기를 기다리는 하나의 프로세스를 명시한다.
두 프로세스가 모두 종료되는 데 얼마의 시간이 걸리는가?-c 플래그를 사용하여
예측한 것이 맞는지 확인하시오.
  
4개의 명령어를 종료하는 시간 + IO를 기다리는 시간만큼 걸릴것이다.  
<img width="906" height="368" alt="image" src="https://github.com/user-attachments/assets/3c291dbb-4d79-4a48-8849-79bc8691f3b1" />


3. 옵션으로 지정된 프로세스의 순서를 꾸시오: ./process-run.py -l 1:0,4:100  
이제 어떤 결과가 나오는가? 실행 순서를 교환하는 것은 중요한가? 이유는 무엇인가? (언제나처럼-c 플래그를 사용하여 예측이 맞는지 확인하오.)

IO작업을 하는동안 프로세스1을 진행시켜 실행시간이 적게 들게 된다.
<img width="902" height="256" alt="image" src="https://github.com/user-attachments/assets/e9a3d6d2-27d5-4f56-932f-3fd4d28bf950" />


4. 자, 다른 플래그에 대해서도 알아보자. 중요한 플래그 중 하나는 -S로서 프로세스가 입출력을 요청했을 때 시스템이 어떻게 반응하는지를 결정한다. 이 플래그가 SWITCH_ON_END로 지정되면 시스템은 요청 프로세스가 입출력을 하는 동안 다른 프로세스로 전환하지 않고 대신 요청 프로세스가 종료될 때까지 기다린다. 입출력만 수행하는 프로세스와 CPU 작만 하는 프로세스 두 개를 실행시키면 어떤 결과가 발생하는가?(-l 1:0,4:200 -c -S SWITCH_ON_END)

온전히 IO가 끝나야 프로세스1을 실행시키기 떄문에 드는 시간은 IO작업+프로세스1이 된다.  
<img width="916" height="376" alt="image" src="https://github.com/user-attachments/assets/02f95adc-2764-4034-8c29-9adf0a53413a" />



5. 이번에는 프로세스가 입출력을 기다릴 때마다 다른 프로세스로 전환하도록 플래그를 지정하여 같은 프로세스를 실행시켜 보자 (-l 1:0,4:100 -c -S SWITCH_ON_IO). 이제 어떤 결과가 생기는가? -c를 사용하여 예측이 맞는지 확인하시오.  
다시 IO작업 진행중 프로세스 1을 돌리기 때문에 더 적은시간이 들것이다.  
<img width="886" height="260" alt="image" src="https://github.com/user-attachments/assets/2d80b4db-3d41-481e-994f-4a1edf4a52ad" />

6. 또 다른 중요한 행동은 입출력이 완료되었을 때 무엇을 하느냐이다.-I IO_RUN_LATER 가 지정되면 입출력이 완료되었을 때 입출력을 요청한 프로세스가 바로 실행될 필요가없다. 완료 시점에 실행 중이던 프로세스가 계속 실행된다. 다음과 같은 조합의 프로
세스를 실행시키면 무슨 결과가 나오는가? 시스템 자원은 효과적으로 활용되는가?  
첫번째 IO는 동시에 실행되었지만 나머지 IO는 지연되었기에 그다지 효과적으로 사용되진 않는다 (CPU 사용률 66.7퍼센트)  
<img width="1322" height="1096" alt="image" src="https://github.com/user-attachments/assets/ac6899ff-d721-4121-bc3a-e178e0db2f3f" />



7. 같은 프로세스 조합을 실행시킬 때-I IO_RUN_IMMEDIATE를 지정하고 실행시키시오. 이 플래그는 입출력이 완료되었을 때 요청 프로세스가 곧바로 실행되는 동작을의미한다. 이 동작은 어떤 결과를 만들어 내는가? 방금 입출력을 완료한 프로세스를 다시 실행시키는 것이 좋은 생각일 수 있는 이유는 무었인가?  
IO가 끝나고 곧바로 다음 IO를 진행시키기때문에 실행 시간이 적어져서 효율적으로 자원을 사용 가능하다.  
<img width="1384" height="794" alt="image" src="https://github.com/user-attachments/assets/be6b3efc-e891-4520-80bb-5502bd11224d" />



8. 이제 다음과 같이 무작위로 생성된 프로세스를 실행시켜 보자. 예를 들면,-s 1 -l 3:50,3:50,-s 2 -l 3:50,3:50,-s 3 -l 3:50,3:50. 어떤 양상을 보일지 예측할 수 있는지 생각해 보시오.-I IO_RUN_IMMEDIATE를 지정했을 때와-I IO_RUN_LATER를 지정했을 때 어떤 결과가 나오는가?-S SWITCH_ON_IO 대-S SWITCH_ON_END의 경우에는 어떤 결과가 나오는가?  

