## 1. 길이가 200인 세 개의 작업을 SJF와 FIFO 스케줄링 방식으로 실행할 경우 응답 시간과 반환 시간을 계산하시오.
FIFO **반환시간** 200+400+600/3 **응답시간** 0+200+400/3    
SJF **반환시간** 200+400+600/3 **응답시간** 0+200+400/3
## 2. 같은 조건이지만 작업의 길이가 각각 100, 200 및 300일 경우에 대해 계산하시오.
FIFO **반환시간** 짧은 작업이 먼저올경우 100+300+600/3 긴 작업이 먼저올경우 300+500+600/3 **응답시간** 짧은 작업이 먼저올경우 0+100+300/3 긴 작업이 먼저올경우 0+300+500/3  
SJF **반환시간** 100+300+600/3 **응답시간** 0+100+300/3
## 3. 2번과 같은 조건으로 타임 슬라이스가 1인 RR 스케줄러에 대해서도 계산하시오.
RR **반환시간** 300+500+600/3 **응답시간** 0+1+2/3    
## 4. SJF와 FIFO가 같은 반환 시간을 보이는 워크로드의 유형은 무엇인가?
짧은 작업이 먼저올 경우다.
## 5. SJF가 RR과 같은 응답 시간을 보이기 위한 워크로드와 타임 퀀텀의 길이는 무엇인가?
모든 워크로드의 소모시간이 같아야 하며 타임 퀀텀보다 소요시간이 작거나 같아야한다.
## 6. 작업의 길이가 증가하면 SJF의 응답 시간은 어떻게 되는가? 변화의 추이를 보이기 위해서 시뮬레이터를 사용할 수 있는가?
작업의 길이가 길면 상대적으로 후순위로 밀리기 때문에 응답시간이 매우 길어지게 된다.
## 7. 타임 퀀텀의 길이가 증가하면 RR의 응답 시간은 어떻게 되는가? N 개의 작업이 주어졌을 때, 최악의 응답 시간을 계산하는 식을 만들 수 있는가?
타임 퀀텀이 길어지는 만큼 다음 작업까지의 대기시간이 길어지게 되므로 응답시간이 길어지게 된다. 결국 N개의 작업이 있을때 타임 퀀텀이 P라면 최악으로 맨 뒤의 작업은 (N-1) * P 만큼의 응답시간이 소요될것

---
# 읽다가 궁금한점 : 반환시간이 사용자 입장에서 중요할것 같은데 왜 응답시간까지 고려할까?
> 결론 : 반환시간만 고려하다보면 길게 처리할때 까지 사용자는 피드백을 받지 못한다.  
> 또한 응답시간만 고려하다 보면 사용자는 즉각적인 반응이 오겠지만 작업 완료까지 느려지게 된다.  
> 그래서 이 둘을 절충하는 수단이 필요하다!
